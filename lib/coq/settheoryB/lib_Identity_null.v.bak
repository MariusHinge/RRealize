(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require set.Set.
Require map.Map.
Require map.Const.

(* Why3 assumption *)
Definition rel (a:Type) (b:Type) := (a* b)%type -> bool.

Parameter infix_plmngt:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> bool) ->
  (b -> bool) -> ((a* b)%type -> bool) -> bool.

Axiom mem_function :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool),
  (set.Set.mem f (infix_plmngt s t)) <->
  ((forall (x:a) (y:b), (set.Set.mem (x, y) f) ->
    (set.Set.mem x s) /\ (set.Set.mem y t)) /\
   forall (x:a) (y1:b) (y2:b),
   ((set.Set.mem (x, y1) f) /\ (set.Set.mem (x, y2) f)) -> (y1 = y2)).

Axiom domain_function :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (x:a) (y:b),
  (set.Set.mem f (infix_plmngt s t)) -> (set.Set.mem (x, y) f) ->
  set.Set.mem x s.

Axiom range_function :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (x:a) (y:b),
  (set.Set.mem f (infix_plmngt s t)) -> (set.Set.mem (x, y) f) ->
  set.Set.mem y t.

Axiom function_extend_range :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (u:b -> bool),
  (set.Set.subset t u) -> (set.Set.mem f (infix_plmngt s t)) ->
  set.Set.mem f (infix_plmngt s u).

Axiom function_reduce_range :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (u:b -> bool),
  (set.Set.subset u t) -> (set.Set.mem f (infix_plmngt s t)) ->
  (forall (x:a) (y:b), (set.Set.mem (x, y) f) -> set.Set.mem y u) ->
  set.Set.mem f (infix_plmngt s u).

Parameter inverse:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  ((a* b)%type -> bool) -> (b* a)%type -> bool.

Axiom Inverse_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (r:(a* b)%type -> bool), forall (x:a) (y:b),
  (set.Set.mem (y, x) (inverse r)) <-> (set.Set.mem (x, y) r).

Parameter dom:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  ((a* b)%type -> bool) -> a -> bool.

Axiom dom_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (r:(a* b)%type -> bool), forall (x:a),
  (set.Set.mem x (dom r)) <-> exists y:b, set.Set.mem (x, y) r.

Parameter ran:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  ((a* b)%type -> bool) -> b -> bool.

Axiom ran_def :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (r:(a* b)%type -> bool), forall (y:b),
  (set.Set.mem y (ran r)) <-> exists x:a, set.Set.mem (x, y) r.

Parameter infix_mnmngt:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b}, (a -> bool) ->
  (b -> bool) -> ((a* b)%type -> bool) -> bool.

Axiom mem_total_functions :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool),
  (set.Set.mem f (infix_mnmngt s t)) <->
  ((set.Set.mem f (infix_plmngt s t)) /\ (set.Set.infix_eqeq (dom f) s)).

Axiom total_function_is_function :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool),
  (set.Set.mem f (infix_mnmngt s t)) -> set.Set.mem f (infix_plmngt s t).

Parameter apply:
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  ((a* b)%type -> bool) -> a -> b.

Axiom apply_def1 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (a1:a),
  ((set.Set.mem a1 s) /\ (set.Set.mem f (infix_mnmngt s t))) ->
  set.Set.mem (a1, apply f a1) f.

Axiom apply_def2 :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool) (a1:a) (b1:b),
  ((set.Set.mem f (infix_mnmngt s t)) /\ (set.Set.mem (a1, b1) f)) ->
  (b1 = (apply f a1)).

Axiom injection :
  forall {a:Type} {a_WT:WhyType a} {b:Type} {b_WT:WhyType b},
  forall (f:(a* b)%type -> bool) (s:a -> bool) (t:b -> bool),
  forall (x:a) (y:a), (set.Set.mem f (infix_mnmngt s t)) ->
  (set.Set.mem (inverse f) (infix_plmngt t s)) -> (set.Set.mem x s) ->
  (set.Set.mem y s) -> ((apply f x) = (apply f y)) -> (x = y).

Parameter id:
  forall {a:Type} {a_WT:WhyType a}, (a -> bool) -> (a* a)%type -> bool.

Axiom id_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a) (s:a -> bool),
  (set.Set.mem (x, y) (id s)) <-> ((set.Set.mem x s) /\ (x = y)).

Axiom id_dom :
  forall {a:Type} {a_WT:WhyType a}, forall (s:a -> bool), ((dom (id s)) = s).

Axiom id_ran :
  forall {a:Type} {a_WT:WhyType a}, forall (s:a -> bool), ((ran (id s)) = s).

Axiom id_fun :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:a -> bool), set.Set.mem (id s) (infix_plmngt s s).

Axiom id_total_fun :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:a -> bool), set.Set.mem (id s) (infix_mnmngt s s).

